#pragma once
#include <string>
#include <queue>
#include <algorithm> 

using std::string;
using std::cout;
using std::endl;
using std::max;

/////////////////// Алгоритм Рабина-Карпа ///////////////////
void search(char pat[], char txt[], int q) {
    
    int M = strlen(pat); // длина шаблона
    int N = strlen(txt); // длина текста    
    int p = 0; // хэш для шаблона
    int t = 0; // хэш для текста
    int h = 1;

    // Начальный  хэш
    // h = pow(d, M-1)%q
    for (size_t i = 0; i < M - 1; i++) {
        h = (h * 256) % q;
    }

    // Вычисление хэша шаблона и хэша первого отрезка текста
    for (size_t i = 0; i < M; i++) {
        p = (256 * p + pat[i]) % q;
        t = (256 * t + txt[i]) % q;
    }

    // Сравнение шаблона с текстом 
    for (size_t i = 0; i <= N - M; i++) {

        // Проверка совпадения хэшей шаблона и текста.
        // Если проверка прошла, производится посимвольная проверка.
        if (p == t) {            
            // Посимвольная проверка
            size_t j = 0;
            for (j = 0; j < M; j++) {
                if (txt[i + j] != pat[j])
                    break;
            }

            if (j == M) {
                cout << "Совпадение на индексе " << i << endl;
            }
        }

        // Вычисление хэша следующего отрезка текста
        if (i < N - M) {
            t = (256 * (t - txt[i] * h) + txt[i + M]) % q;
            
            // Если получилось отрицательное число, преобразуем в положительное
            if (t < 0) {
                t = (t + q);
            }
        }
    }
}
//////////////////////////////////////////////////////////

/////////////////// Алгоритм Кнута-Мориса-Прата ///////////////////

// Предпроцессинг. В массив lps записывается, сколько символов нужно пропустить
// при каждом шаге сравнения шаблона и текста.
// lps - longest proper prefix (наидлиннейший корректный префикс)
void computeLPSArray(char* pat, int M, int* lps) {

    // Длинна предыдущего наидлиннейшего корректного префикса
    int len = 0;

    // Начальный отступ всегда 0 (первое сравнение)
    lps[0] = 0;

    // вычисление lps[i] от i = 1 до M-1 
    size_t i = 1;
    while (i < M) {
        if (pat[i] == pat[len]) {
            len++;
            lps[i] = len;
            i++;
        }
        else {
            if (len != 0) {
                len = lps[len - 1];
            }
            else
            {
                lps[i] = 0;
                i++;
            }
        }
    }
}

void KMPSearch(char* pat, char* txt)
{
    int M = strlen(pat); // Чтение шаблона
    int N = strlen(txt); // Чтение текста

    // Предпроцессинг
    int* lps = new int[M];
    computeLPSArray(pat, M, lps);

    size_t i = 0; // индекс для текста
    size_t j = 0; // индекс для шаблона

    while (i < N) {
        if (pat[j] == txt[i]) {
            j++;
            i++;
        }

        if (j == M) {
            cout << "Совпадение на индексе " << i - j << endl;
            j = lps[j - 1];
        }
        else {
            // Несовпадение с шаблоном после j совпадений
            if (i < N && pat[j] != txt[i]) {
                if (j != 0)
                    j = lps[j - 1];
                else
                    i = i + 1;
            }
        }
    }
}
//////////////////////////////////////////////////////////


/////////////////// Алгоритм Боуера-Мура ///////////////////

// Предпроцессинг. (Эвристика стоп-символа)
// Если встречающийся символ в тексте отсутствует в шаблоне, искать шаблон там бессмысленно.
// Будем производить сдвиг до первого символа, который есть в шаблоне.
// Такие сдвиги запишем в массив.
void heuristic(string str, int size, int badchar[256]) {
    for (size_t i = 0; i < 256; i++) {
        badchar[i] = -1;
    }
    
    for (size_t i = 0; i < size; i++) {
        badchar[(int)str[i]] = i;           
    }        
}

void search(string txt, string pat) {    
    int m = pat.size();  // длина шаблона
    int n = txt.size();  // длина текста

    int badchar[256];  
    heuristic(pat, m, badchar);
    
    int s = 0; // Cдвиг шаблона по отношению к тексту

    while (s <= (n - m))
    {
        int j = m - 1;

        // Уменьшаем индекс j шаблона, пока символы шаблона и текста совпадают на текущем сдвиге
        while (j >= 0 && pat[j] == txt[s + j]) {
            j--;
        }

        if (j < 0)
        {
            cout << "Совпадение на индексе " << s << endl;

            // Сдвиг шаблона
            s += (s + m < n) ? m - badchar[txt[s + m]] : 1;

        }
        else {
            // Сдвиг шаблона
            s += max(1, j - badchar[txt[s + j]]);
        }
    }
}